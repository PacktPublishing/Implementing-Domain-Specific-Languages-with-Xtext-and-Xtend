/*
 * generated by Xtext 2.10.0
 */
package org.example.smalljava.validation

import com.google.common.collect.HashMultimap
import com.google.inject.Inject
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.validation.CheckType
import org.example.smalljava.SmallJavaModelUtil
import org.example.smalljava.scoping.SmallJavaIndex
import org.example.smalljava.smallJava.SJBlock
import org.example.smalljava.smallJava.SJClass
import org.example.smalljava.smallJava.SJExpression
import org.example.smalljava.smallJava.SJField
import org.example.smalljava.smallJava.SJMemberSelection
import org.example.smalljava.smallJava.SJMethod
import org.example.smalljava.smallJava.SJNamedElement
import org.example.smalljava.smallJava.SJProgram
import org.example.smalljava.smallJava.SJReturn
import org.example.smalljava.smallJava.SJSuper
import org.example.smalljava.smallJava.SJVariableDeclaration
import org.example.smalljava.smallJava.SmallJavaPackage
import org.example.smalljava.typing.SmallJavaTypeComputer
import org.example.smalljava.typing.SmallJavaTypeConformance

import static extension org.eclipse.xtext.EcoreUtil2.*

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class SmallJavaValidator extends AbstractSmallJavaValidator {

	protected static val ISSUE_CODE_PREFIX = "org.example.smalljava."
	public static val HIERARCHY_CYCLE = ISSUE_CODE_PREFIX + "HierarchyCycle"
	public static val FIELD_SELECTION_ON_METHOD = ISSUE_CODE_PREFIX + "FieldSelectionOnMethod"
	public static val METHOD_INVOCATION_ON_FIELD = ISSUE_CODE_PREFIX + "MethodInvocationOnField"
	public static val UNREACHABLE_CODE = ISSUE_CODE_PREFIX + "UnreachableCode"
	public static val MISSING_FINAL_RETURN = ISSUE_CODE_PREFIX + "MissingFinalReturn"
	public static val DUPLICATE_ELEMENT = ISSUE_CODE_PREFIX + "DuplicateElement"
	public static val INCOMPATIBLE_TYPES = ISSUE_CODE_PREFIX + "IncompatibleTypes"
	public static val INVALID_ARGS = ISSUE_CODE_PREFIX + "InvalidArgs"
	public static val WRONG_METHOD_OVERRIDE = ISSUE_CODE_PREFIX + "WrongMethodOverride"
	public static val MEMBER_NOT_ACCESSIBLE = ISSUE_CODE_PREFIX + "MemberNotAccessible"
	public static val DUPLICATE_CLASS = ISSUE_CODE_PREFIX + "DuplicateClass"
	public static val WRONG_SUPER_USAGE = ISSUE_CODE_PREFIX + "WrongSuperUsage"
	public static val REDUCED_ACCESSIBILITY = ISSUE_CODE_PREFIX + "ReducedAccessibility"

	@Inject extension SmallJavaModelUtil
	@Inject extension SmallJavaTypeComputer
	@Inject extension SmallJavaTypeConformance
	@Inject extension SmallJavaAccessibility
	@Inject extension SmallJavaIndex
	@Inject extension IQualifiedNameProvider

	@Check
	def checkClassHierarchy(SJClass c) {
		if (c.classHierarchy.contains(c)) {
			error("cycle in hierarchy of class '" + c.name + "'",
				SmallJavaPackage.eINSTANCE.SJClass_Superclass,
				HIERARCHY_CYCLE, c.superclass.name)
		}
	}

	@Check
	def void checkMemberSelection(SJMemberSelection sel) {
		val member = sel.member

		if (member instanceof SJField && sel.methodinvocation)
			error(
				'''Method invocation on a field''',
				SmallJavaPackage.eINSTANCE.SJMemberSelection_Methodinvocation,
				METHOD_INVOCATION_ON_FIELD)
		else if (member instanceof SJMethod && !sel.methodinvocation)
			error(
				'''Field selection on a method''',
				SmallJavaPackage.eINSTANCE.SJMemberSelection_Member,
				FIELD_SELECTION_ON_METHOD
			)
	}

	@Check
	def void checkUnreachableCode(SJBlock block) {
		val statements = block.statements
		for (var i = 0; i < statements.length-1; i++) {
			if (statements.get(i) instanceof SJReturn) {
				// put the error on the statement after the return
				error("Unreachable code",
					statements.get(i+1),
					null, // EStructuralFeature
					UNREACHABLE_CODE)
				return // no need to report further errors
			}
		}
	}

	@Check
	def void checkMethodEndsWithReturn(SJMethod method) {
		if (method.returnStatement === null) {
			error("Method must end with a return statement",
				SmallJavaPackage.eINSTANCE.SJMethod_Body,
				MISSING_FINAL_RETURN
			)
		}
	}

	@Check def void checkNoDuplicateClasses(SJProgram p) {
		checkNoDuplicateElements(p.classes, "class")
	}

	@Check def void checkNoDuplicateMembers(SJClass c) {
		checkNoDuplicateElements(c.fields, "field")
		checkNoDuplicateElements(c.methods, "method")
	}

	@Check def void checkNoDuplicateSymbols(SJMethod m) {
		checkNoDuplicateElements(m.params, "parameter")
		checkNoDuplicateElements(m.body.getAllContentsOfType(SJVariableDeclaration), "variable")
	}

	@Check def void checkConformance(SJExpression exp) {
		val actualType = exp.typeFor
		val expectedType = exp.expectedType
		if (expectedType === null || actualType === null)
			return; // nothing to check
		if (!actualType.isConformant(expectedType)) {
			error("Incompatible types. Expected '" + expectedType.name + "' but was '" + actualType.name + "'",
				null, INCOMPATIBLE_TYPES);
		}
	}

	@Check def void checkMethodInvocationArguments(SJMemberSelection sel) {
		val method = sel.member
		if (method instanceof SJMethod) {
			if (method.params.size != sel.args.size) {
				error("Invalid number of arguments: expected " + method.params.size + " but was " + sel.args.size,
					SmallJavaPackage.eINSTANCE.SJMemberSelection_Member, INVALID_ARGS)
			}
		}
	}

	@Check def void checkMethodOverride(SJClass c) {
		val hierarchyMethods = c.classHierarchyMethods

		for (m : c.methods) {
			val overridden = hierarchyMethods.get(m.name)
			if (overridden !== null &&
				(!m.type.isConformant(overridden.type) ||
				!m.params.map[type].elementsEqual(overridden.params.map[type]))) {
				error("The method '" + m.name + "' must override a superclass method",
					m, SmallJavaPackage.eINSTANCE.SJNamedElement_Name,
					WRONG_METHOD_OVERRIDE)
			} else if (m.access < overridden.access) {
				error("Cannot reduce access from " + overridden.access +
					" to " + m.access,
					m, SmallJavaPackage.eINSTANCE.SJMember_Access,
					REDUCED_ACCESSIBILITY)
			}
		}
	}

	@Check def void checkAccessibility(SJMemberSelection sel) {
		val member = sel.member
		if (member.name !== null && !member.isAccessibleFrom(sel))
			error(
				'''The «member.access» member «member.name» is not accessible here''',
				SmallJavaPackage.eINSTANCE.SJMemberSelection_Member,
				MEMBER_NOT_ACCESSIBLE
			)
	}

	// perform this check only on file save
	@Check(CheckType.NORMAL)
	def checkDuplicateClassesInFiles(SJProgram p) {
		val externalClasses = p.getVisibleExternalClassesDescriptions
		for (c : p.classes) {
			val className = c.fullyQualifiedName
			if (externalClasses.containsKey(className)) {
				error("The type " + c.name + " is already defined",
					c,
					SmallJavaPackage.eINSTANCE.SJNamedElement_Name,
					DUPLICATE_CLASS)
			}
		}
	}

	@Check
	def void checkSuper(SJSuper s) {
		if (s.eContainingFeature != SmallJavaPackage.eINSTANCE.SJMemberSelection_Receiver)
			error("'super' can be used only as member selection receiver", null, WRONG_SUPER_USAGE)
	}

	def private void checkNoDuplicateElements(Iterable<? extends SJNamedElement> elements, String desc) {
		val multiMap = HashMultimap.create()

		for (e : elements)
			multiMap.put(e.name, e)

		for (entry : multiMap.asMap.entrySet) {
			val duplicates = entry.value
			if (duplicates.size > 1) {
				for (d : duplicates)
					error(
						"Duplicate " + desc + " '" + d.name + "'",
						d,
						SmallJavaPackage.eINSTANCE.SJNamedElement_Name, 
						DUPLICATE_ELEMENT)
			}
		}
	}
}
