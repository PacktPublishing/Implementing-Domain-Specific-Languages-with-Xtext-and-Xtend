/*
 * generated by Xtext 2.10.0
 */
package org.example.smalljava.generator

import com.google.inject.Inject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.example.smalljava.SmallJavaLib
import org.example.smalljava.SmallJavaModelUtil
import org.example.smalljava.smallJava.SJAssignment
import org.example.smalljava.smallJava.SJBlock
import org.example.smalljava.smallJava.SJBoolConstant
import org.example.smalljava.smallJava.SJClass
import org.example.smalljava.smallJava.SJIfStatement
import org.example.smalljava.smallJava.SJIntConstant
import org.example.smalljava.smallJava.SJMemberSelection
import org.example.smalljava.smallJava.SJNew
import org.example.smalljava.smallJava.SJNull
import org.example.smalljava.smallJava.SJParameter
import org.example.smalljava.smallJava.SJProgram
import org.example.smalljava.smallJava.SJReturn
import org.example.smalljava.smallJava.SJStatement
import org.example.smalljava.smallJava.SJStringConstant
import org.example.smalljava.smallJava.SJSuper
import org.example.smalljava.smallJava.SJSymbolRef
import org.example.smalljava.smallJava.SJThis
import org.example.smalljava.smallJava.SJVariableDeclaration

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SmallJavaGenerator extends AbstractGenerator {

	@Inject extension IQualifiedNameProvider
	@Inject extension SmallJavaModelUtil

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val program = resource.allContents.toIterable.filter(SJProgram).head
		// an empty program is a valid SmallJava program
		if (program === null)
			return;
		// don't compile the classes of the SmallJava library
		if (program.name == "smalljava.lang")
			return;
		for (smallJavaClass : program.classes) {
			fsa.generateFile
				(smallJavaClass.fullyQualifiedName.toString.replace(".", "/") + ".java",
				'''
				«IF program.name !== null»
				package «program.name»;
				
				«ENDIF»
				public class «smallJavaClass.name» «IF smallJavaClass.superclass !== null»extends «smallJavaClass.superclass.compileTypeReference» «ENDIF»{
					«FOR field : smallJavaClass.fields»
					«field.access» «field.type.compileTypeReference» «field.name»;
					«ENDFOR»
					«FOR method : smallJavaClass.methods»
					«method.access» «method.type.compileTypeReference» «method.name»(«method.params.map[compileParam].join(", ")») «compileBlock(method.body)»
					«ENDFOR»
				}
				'''
			)
		}
	}

	def compileTypeReference(SJClass c) {
		val fqn = c.fullyQualifiedName.toString
		switch (fqn) {
			case fqn == SmallJavaLib.LIB_OBJECT : "Object"
			case fqn == SmallJavaLib.LIB_STRING : "String"
			case fqn == SmallJavaLib.LIB_INTEGER : "Integer"
			case fqn == SmallJavaLib.LIB_BOOLEAN : "Boolean"
			default: fqn
		}
	}

	def compileParam(SJParameter p) {
		'''«p.type.compileTypeReference» «p.name»'''
	}

	def compileBlock(SJBlock block) '''
		{
			«FOR s : block.statements»
			«compileStatement(s)»
			«ENDFOR»
		}
	'''

	def String compileStatement(SJStatement s) {
		switch (s) {
			SJVariableDeclaration: '''«s.type.compileTypeReference» «s.name» = «s.expression.compileExpression»;'''
			SJReturn: "return " + s.expression.compileExpression + ";"
			SJIfStatement: '''
			if («s.expression.compileExpression»)
				«s.thenBlock.compileBlock»
			«IF s.elseBlock !== null»
			else
				«s.elseBlock.compileBlock»
			«ENDIF»
			'''
			default: s.compileExpression + ";"
		}
	}

	def String compileExpression(SJStatement s) {
		switch (s) {
			SJStringConstant: '"' + s.value + '"'
			SJIntConstant: s.value.toString
			SJBoolConstant: s.value
			SJNull: "null"
			SJThis: "this"
			SJSuper: "super"
			SJSymbolRef: s.symbol.name
			SJNew: "new " + s.type.compileTypeReference + "()"
			SJAssignment: {
				s.left.compileExpression + " = " + s.right.compileExpression
			}
			SJMemberSelection: {
				s.receiver.compileExpression + "." + s.member.name +
				if (s.methodinvocation) {
					"(" + s.args.map[compileExpression].join(", ") + ")"
				} else {
					""
				}
			}
		}
	}
}
